using System.Globalization;
using System.Text;
using Catalyst.SpecGraph.Nodes;
using Catalyst.SpecGraph.Properties;

namespace Catalyst.LanguageCompilers.Unreal;

public class UnrealLanguageCompiler : LanguageCompiler
{
    public override string CompilerName => UnrealLanguage.Name;

    public override CompiledFile CompileFile(File file)
    {
        StringBuilder sb = new();
        
        sb.AppendLine("//");
        sb.AppendLine($"// This file was generated by Catalyst's Unreal compiler at {DateTime.Now}.");
        sb.AppendLine("// It is recommended not to modify this file. Modify the source spec file instead.");
        sb.AppendLine("//");
        sb.AppendLine();
        
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        
        file.Includes.Add(new Include("JsonObjectConverter"));
        file.Includes.Add(new Include("Templates/SharedPointer"));

        if (file.Includes.Count > 0)
        {
            foreach (Include include in file.Includes)
            {
                string includePath = Path.ChangeExtension(include.Path, ".h");
                sb.AppendLine($"#include \"{includePath}\"");
            }
            sb.AppendLine();
        }

        sb.AppendLine($"#include \"{Path.GetFileNameWithoutExtension(file.Name)}.generated.h\"");
        sb.AppendLine();
        
        foreach (Class def in file.Definitions)
        {
            sb.AppendLine("USTRUCT(BlueprintType)");
            sb.AppendLine($"struct {def.Name}").AppendLine("{");
            sb.AppendLine("    GENERATED_BODY()");

            foreach (Property property in def.Properties)
            {
                sb.AppendLine();
                sb.Append("    UPROPERTY(EditAnywhere");
                /*if (property.Attributes.Count > 0)
                {
                    foreach (Attribute attribute in property.Attributes)
                    {
                        sb.Append($", {attribute.Name}");
                        if (!string.IsNullOrWhiteSpace(attribute.Arguments))
                            sb.Append($" = {attribute.Arguments}");
                    }
                }*/
                sb.AppendLine(")");

                sb.Append($"    {property.Type.Name} {property.Name}");
                
                if (property.Value is not NoPropertyValue)
                    sb.Append($" = {property.Value.Value};");
                else
                    sb.Append(";");
                
                sb.AppendLine();
            }

            foreach (Function function in def.Functions)
            {
                sb.AppendLine();

                sb.Append("    ");
                
                if (function.Flags is FunctionFlags.Static)
                    sb.Append("static ");

                sb.Append($"{function.ReturnType} {function.Name}(");

                for (int parameterIdx = 0; parameterIdx < function.Parameters.Count; parameterIdx++)
                {
                    sb.Append(function.Parameters[parameterIdx]);
                    if (parameterIdx < function.Parameters.Count - 1)
                        sb.Append(", ");
                }
                
                sb.Append(")");

                if (function.Flags is FunctionFlags.Const)
                    sb.Append(" const");

                sb.AppendLine();
                
                sb.AppendLine("    {");

                string[] bodyLines = function.Body.Split(Environment.NewLine);
                foreach (string line in bodyLines)
                    sb.AppendLine($"        {line}");
                
                sb.AppendLine("    }");
            }

            sb.AppendLine("};").AppendLine();
        }

        return new CompiledFile(file.Name, sb.ToString());
    }

    protected override string GetCompiledFilePath(FileNode fileNode)
    {
        string newFileName = fileNode.FileName.ToPascalCase() + ".h";
        
        // Add the File's Unreal prefix, if it has one.
        var compilerOptions = fileNode.FindCompilerOptions<UnrealFileCompilerOptionsNode>()!;
        if (!string.IsNullOrEmpty(compilerOptions.Prefix))
            newFileName = compilerOptions.Prefix + newFileName;
        else
        {
            // Add a prefix using the namespace as a fallback.
            string? namespacePrefix = GetPrefixFromNamespace(fileNode);
            if (!string.IsNullOrEmpty(namespacePrefix))
                newFileName = namespacePrefix + newFileName;
        }
        
        
        string newFilePath = Path.Combine(StringExtensions.FilePathToPascalCase(fileNode.Directory) ?? string.Empty, newFileName);
        
        return newFilePath;
    }

    protected override string? GetCompiledNamespace(FileNode fileNode)
    {
        // Unreal doesn't support namespaces for reflection-based classes and structs.
        return null;
    }

    protected override string GetCompiledClassName(DefinitionNode definitionNode)
    {
        // Get the Property Type Name without any namespace info.
        string propertyTypeName = definitionNode.Name.ToPascalCase();
                
        // Add the Property Type's Unreal prefix, if it has one.
        var compilerOptions = definitionNode.FindCompilerOptions<UnrealDefinitionCompilerOptionsNode>()!;
        if (!string.IsNullOrEmpty(compilerOptions.Prefix))
            propertyTypeName = compilerOptions.Prefix + propertyTypeName;
        else
        {
            // Add a prefix using the namespace as a fallback.
            string? namespacePrefix = GetPrefixFromNamespace(definitionNode.GetParentChecked<FileNode>());
            if (!string.IsNullOrEmpty(namespacePrefix))
                propertyTypeName = namespacePrefix + propertyTypeName;
        }

        // Unreal requires structs to be prefixed with F.
        return $"F{propertyTypeName}";
    }

    protected override string GetCompiledPropertyName(PropertyNode propertyNode)
    {
        return propertyNode.Name.ToPascalCase();
    }

    protected override string GetCompiledServiceName(ServiceNode serviceNode)
    {
        return serviceNode.Name.ToPascalCase();
    }

    protected override string GetCompiledEndpointName(EndpointNode endpointNode)
    {
        return endpointNode.Name.ToPascalCase();
    }

    protected override Include? GetCompiledIncludeForPropertyType(File file, IPropertyType propertyType)
    {
        switch (propertyType)
        {
            case AnyType:
                return new Include("StructUtils/InstancedStruct");
            case DateType:
                return new Include("Misc/DateTime");
            case TimeType:
                return new Include("Misc/Timespan");
            case ObjectType objectType:
                string compiledFileName = GetCompiledFilePath(objectType.OwnedFile);
                if (compiledFileName != file.Name)
                    return new Include(compiledFileName);
                break;
        }
        
        return null;
    }

    protected override PropertyType GetCompiledPropertyType(IPropertyType propertyType)
    {
        PropertyType genPropertyType;
        switch (propertyType)
        {
            case AnyType:
                genPropertyType = new PropertyType("FInstancedStruct");
                break;
            case BooleanType:
                genPropertyType = new PropertyType("bool");
                break;
            case DateType:
                genPropertyType = new PropertyType("FDateTime");
                break;
            case FloatType:
                genPropertyType = new PropertyType("double");
                break;
            case IntegerType:
                genPropertyType = new PropertyType("int32");
                break;
            case ListType listType:
                PropertyType innerListPropertyType = GetCompiledPropertyType(listType.InnerType);
                genPropertyType = new PropertyType($"TArray<{innerListPropertyType.Name}>");
                break;
            case MapType mapType:
                PropertyType innerKeyPropertyType = GetCompiledPropertyType(mapType.InnerTypeA);
                PropertyType innerValuePropertyType = GetCompiledPropertyType(mapType.InnerTypeB);
                genPropertyType = new PropertyType($"TMap<{innerKeyPropertyType.Name}, {innerValuePropertyType.Name}>");
                break;
            case SetType setType:
                PropertyType innerSetPropertyType = GetCompiledPropertyType(setType.InnerType);
                genPropertyType = new PropertyType($"TSet<{innerSetPropertyType.Name}>");
                break;
            case StringType:
                genPropertyType = new PropertyType("FString");
                break;
            case TimeType:
                genPropertyType = new PropertyType("FTimespan");
                break;
            case ObjectType userType:
                genPropertyType = new PropertyType(GetCompiledClassName(userType.OwnedDefinition));
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(propertyType));
        }

        if (propertyType is IOptionalPropertyType)
            genPropertyType = new PropertyType($"TOptional<{genPropertyType.Name}>");

        return genPropertyType;
    }

    protected override PropertyValue GetCompiledDefaultValueForPropertyType(IPropertyType propertyType)
    {
        return propertyType switch
        {
            IOptionalPropertyType => new NoPropertyValue(),
            BooleanType => new SomePropertyValue("false"),
            IntegerType or FloatType => new SomePropertyValue("0"),
            _ => new NoPropertyValue()
        };
    }

    protected override PropertyValue GetCompiledDesiredPropertyValue(IPropertyValue propertyValue)
    {
        switch (propertyValue)
        {
            case BooleanValue booleanValue:
                return new SomePropertyValue(booleanValue.Value ? "true" : "false");
            case DateValue dateValue:
                // Unreal doesn't have a DateTime initialiser for ISO, so need to convert to unix.
                long unixMs = new DateTimeOffset(dateValue.Value).ToUnixTimeMilliseconds();
                double unixS = unixMs / 1000d;
                return new SomePropertyValue($"FDateTime::FromUnixTimestamp({unixS})");
            case FloatValue floatValue:
                return new SomePropertyValue(floatValue.Value.ToString(CultureInfo.InvariantCulture));
            case IntegerValue integerValue:
                return new SomePropertyValue(integerValue.Value.ToString(CultureInfo.InvariantCulture));
            case ListValue listValue:
                StringBuilder sb = new();
                sb.Append('[');
                for (int itemIdx = 0; itemIdx < listValue.Values.Count; itemIdx++)
                {
                    IPropertyValue itemValue = listValue.Values[itemIdx];
                    sb.Append(GetCompiledDesiredPropertyValue(itemValue));
                    if (itemIdx < listValue.Values.Count - 1)
                        sb.Append(", ");
                }
                sb.Append(']');
                return new SomePropertyValue(sb.ToString());
            case MapValue mapValue:
                throw new NotImplementedException();
            case NullValue nullValue:
                return new SomePropertyValue("null");
            case ObjectValue objectValue:
                throw new NotImplementedException();
            case StringValue stringValue:
                return new SomePropertyValue($"\"{stringValue.Value}\"");
            case TimeValue timeValue:
                return new SomePropertyValue($"FTimespan::FromSeconds({timeValue.Value.TotalSeconds.ToString(CultureInfo.InvariantCulture)})");
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    protected override IEnumerable<Function> CreateSerialiseFunction(File file, DefinitionNode definitionNode)
    {
        // This implementation could easily be templated for every definition but that 
        // requires dependencies for the project, making it less portable.
        
        StringBuilder mainSerialiseFunc = new();
        mainSerialiseFunc
            .AppendLine("TRACE_CPUPROFILER_EVENT_SCOPE(Catalyst::ToJsonBytes)")
            .AppendLine()
            .AppendLine("TSharedPtr<FJsonObject> JsonObject = FJsonObjectConverter::UStructToJsonObject(Object);")
            .AppendLine("if (!JsonObject)")
            .AppendLine("{")
            .AppendLine($"    UE_LOG(LogSerialization, Error, TEXT(\"Could not serialise object '{GetCompiledClassName(definitionNode)}' into a JSON object\"));")
            .AppendLine("    return {};")
            .AppendLine("}")
            .AppendLine()
            .AppendLine("TArray<uint8> Buffer;")
            .AppendLine("FMemoryWriter MemoryWriter(Buffer);")
            .AppendLine("TSharedRef<TJsonWriter<UTF8CHAR>> JsonWriter = TJsonWriterFactory<UTF8CHAR>::Create(&MemoryWriter);")
            .AppendLine("if (!FJsonSerializer::Serialize(JsonObject.ToSharedRef(), JsonWriter))")
            .AppendLine("{")
            .AppendLine($"    UE_LOG(LogSerialization, Error, TEXT(\"Could not serialise JSON object '{GetCompiledClassName(definitionNode)}' into bytes\"));")
            .AppendLine("    return {};")
            .AppendLine("}")
            .AppendLine()
            .Append("return Buffer;");
        
        return [
            new Function(
                Name: "ToBytes",
                ReturnType: "TArray<uint8>",
                Flags: FunctionFlags.Static,
                Parameters: [$"const {GetCompiledClassName(definitionNode)}& Object"],
                Body: mainSerialiseFunc.ToString()),
            new Function(
                Name: "ToBytes",
                ReturnType: "TArray<uint8>",
                Flags: FunctionFlags.Const,
                Parameters: [],
                Body: "return ToBytes(*this);"
            )
        ];
    }

    protected override IEnumerable<Function> CreateDeserialiseFunction(File file, DefinitionNode definitionNode)
    {
        // This implementation could easily be templated for every definition but that 
        // requires dependencies for the project, making it less portable.
        
        StringBuilder sb = new();
        sb
            .AppendLine("TRACE_CPUPROFILER_EVENT_SCOPE(Catalyst::FromJsonBytes)")
            .AppendLine()
            .AppendLine("FMemoryReader MemoryReader(Bytes);")
            .AppendLine()
            .AppendLine("TSharedPtr<FJsonObject> JsonObject;")
            .AppendLine("TSharedRef<TJsonReader<UTF8CHAR>> JsonReader = TJsonReaderFactory<UTF8CHAR>::Create(&MemoryReader);")
            .AppendLine("if (!FJsonSerializer::Deserialize(JsonReader, JsonObject) || !JsonObject)")
            .AppendLine("{")
            .AppendLine($"    UE_LOG(LogSerialization, Error, TEXT(\"Could not deserialise the given bytes for '{GetCompiledClassName(definitionNode)}' into a JSON object\"));")
            .AppendLine("    return {};")
            .AppendLine("}")
            .AppendLine()
            .AppendLine($"{GetCompiledClassName(definitionNode)} DeserialisedObject;")
            .AppendLine("FText FailReason;")
            .AppendLine()
            .AppendLine("bool bConvertedToStruct;")
            .AppendLine("{")
            .AppendLine("    FGCScopeGuard LockGC;")
            .AppendLine($"    bConvertedToStruct = FJsonObjectConverter::JsonObjectToUStruct<{GetCompiledClassName(definitionNode)}>(")
            .AppendLine("        JsonObject.ToSharedRef(),")
            .AppendLine("        &DeserialisedObject,")
            .AppendLine("        /* CheckFlags */ 0,")
            .AppendLine("        /* SkipFlags */ 0,")
            .AppendLine("        /* bStrictMode */ false,")
            .AppendLine("        OUT &FailReason);")
            .AppendLine("}")
            .AppendLine()
            .AppendLine("if (!bConvertedToStruct)")
            .AppendLine("{")
            .AppendLine($"    UE_LOG(LogSerialization, Error, TEXT(\"Could not deserialise the JSON object into an '{GetCompiledClassName(definitionNode)}' object. Reason: %s\"), *FailReason.ToString());")
            .AppendLine("    return {};")
            .AppendLine("}")
            .AppendLine()
            .Append("return DeserialisedObject;");

        return  [
            new Function(
                Name: "FromBytes",
                ReturnType: $"TOptional<{GetCompiledClassName(definitionNode)}>",
                Flags: FunctionFlags.Static,
                Parameters: ["const TArray<uint8>& Bytes"],
                Body: sb.ToString())
        ];
    }

    string? GetPrefixFromNamespace(FileNode fileNode)
    {
        string? namespacePrefix = fileNode.Namespace.ToPascalCase()?.Replace(".", "");
        return namespacePrefix;
    }
}