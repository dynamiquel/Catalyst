using System.Globalization;
using System.Text;
using Catalyst.SpecGraph.Nodes;
using Catalyst.SpecGraph.Properties;
using HttpMethod = Catalyst.SpecGraph.Nodes.HttpMethod;

namespace Catalyst.LanguageCompilers.CSharp;

public class CSharpLanguageCompiler : LanguageCompiler
{
    public override string CompilerName => CSharpLanguage.Name;

    public override CompiledFile CompileFile(File file)
    {
        StringBuilder sb = new();
        
        sb.AppendLine("//");
        sb.AppendLine($"// This file was generated by Catalyst's C# compiler at {DateTime.Now}.");
        sb.AppendLine("// It is recommended not to modify this file. Modify the source spec file instead.");
        sb.AppendLine("//");
        sb.AppendLine();

        if (file.Includes.Count > 0)
        {
            foreach (Include include in file.Includes)
                sb.AppendLine($"using {include.Path};");
            sb.AppendLine();
        }

        if (!string.IsNullOrWhiteSpace(file.Namespace))
            sb.AppendLine($"namespace {file.Namespace};").AppendLine();

        foreach (Class def in file.Definitions)
        {
            if (!string.IsNullOrEmpty(def.Node.Description))
            {
                sb.AppendLine("/// <summary>");
                string[] descLines = def.Node.Description.Split('\n');
                foreach (string descLine in descLines)
                    sb.AppendLine($"/// {descLine}");
                sb.AppendLine("/// </summary>");
            }
            
            CSharpClassType classType = def.Node.FindCompilerOptions<CSharpDefinitionCompilerOptionsNode>()!.Type;
            string classTypeStr = classType == CSharpClassType.Class ? "class" : "record";
            sb.AppendLine($"public {classTypeStr} {def.Name}").AppendLine("{");

            foreach (Property property in def.Properties)
            {
                /*if (property.Attributes.Count > 0)
                {
                    sb.Append("    ");
                    foreach (Attribute attribute in property.Attributes)
                    {
                        sb.Append($"[{attribute.Name}");
                        if (!string.IsNullOrWhiteSpace(attribute.Arguments))
                            sb.Append($"({attribute.Arguments})");
                        sb.AppendLine("]");
                    }
                }*/

                if (!string.IsNullOrEmpty(property.Node.Description))
                {
                    sb.AppendLine("    /// <summary>");
                    string[] descLines = property.Node.Description.Split('\n');
                    foreach (string descLine in descLines)
                        sb.AppendLine($"    /// {descLine}");
                    sb.AppendLine("    /// </summary>");
                }

                bool useRequired = property.Node.FindCompilerOptions<CSharpPropertyCompilerOptionsNode>()!.UseRequired;
                
                sb.Append("    public");
                if (useRequired && !property.Type.Name.EndsWith("?"))
                    sb.Append(" required");

                sb.Append($" {property.Type.Name} {property.Name} {{ get; set; }}");
                
                if (!useRequired && property.Value is not NoPropertyValue)
                    sb.Append($" = {property.Value.Value};");
                
                sb.AppendLine();
                sb.AppendLine();
            }

            foreach (Function function in def.Functions)
            {
                sb.AppendLine();
                
                sb.Append("    public ");
                
                if (function.Flags is FunctionFlags.Static)
                    sb.Append("static ");

                sb.Append($"{function.ReturnType} {function.Name}(");

                for (int parameterIdx = 0; parameterIdx < function.Parameters.Count; parameterIdx++)
                {
                    sb.Append(function.Parameters[parameterIdx]);
                    if (parameterIdx < function.Parameters.Count - 1)
                        sb.Append(", ");
                }
                
                sb.AppendLine(")");
                
                sb.AppendLine("    {");

                sb.AppendLine($"        {function.Body}");
                
                sb.AppendLine("    }");
            }

            sb.AppendLine("}").AppendLine();
        }

        foreach (Service service in file.Services)
        {
            // Generate Client
            
            sb.AppendLine($"public class {service.Name}ClientOptions");
            sb.AppendLine("{");
            sb.AppendLine("    public required string Url { get; set; }");
            sb.AppendLine("}");
            sb.AppendLine("");

            if (!string.IsNullOrEmpty(service.Node.Description))
            {
                sb.AppendLine("/// <summary>");
                string[] descLines = service.Node.Description.Split('\n');
                foreach (string descLine in descLines)
                    sb.AppendLine($"/// {descLine}");
                sb.AppendLine("/// </summary>");
            }

            sb.AppendLine($"public class {service.Name}Client(");
            sb.AppendLine("    HttpClient httpClient,");
            sb.AppendLine($"    {service.Name}ClientOptions options)");
            sb.AppendLine("{");
            foreach (Endpoint endpoint in service.Endpoints)
            {
                string nullableResponseType = endpoint.ResponseType.Name;
                if (!nullableResponseType.EndsWith("?"))
                    nullableResponseType += "?";

                sb.AppendLine($"    public async Task<{endpoint.ResponseType.Name}> {endpoint.Name}({endpoint.ResponseType.Name} request)");
                sb.AppendLine("    {");
                sb.AppendLine("        HttpRequestMessage httpRequest = new()");
                sb.AppendLine("        {");
                sb.AppendLine($"            Method = HttpMethod.{endpoint.Node.Method},");
                sb.AppendLine($"            RequestUri = new Uri(options.Url + \"{service.Node.Path}\" + \"{endpoint.Node.Path}\"),");
                sb.AppendLine("            Content = new ByteArrayContent(request.ToBytes()),");
                sb.AppendLine("            Headers = { {\"Content-Type\", \"application/json; charset=utf-8\" }}");
                sb.AppendLine("        };");
                sb.AppendLine();
                sb.AppendLine("        HttpResponseMessage httpResponse = await httpClient.SendAsync(httpRequest).ConfigureAwait(false);");
                sb.AppendLine("        if (!httpResponse.IsSuccessStatusCode)");
                sb.AppendLine("            throw new Exception(httpResponse.ReasonPhrase);");
                sb.AppendLine();
                sb.AppendLine("        byte[] responseBytes = await httpResponse.Content.ReadAsByteArrayAsync().ConfigureAwait(false);");
                sb.AppendLine($"        {nullableResponseType} response = {endpoint.ResponseType.Name}.FromBytes(responseBytes);");
                sb.AppendLine("        return response;");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
            sb.AppendLine("}");
        }

        foreach (Service service in file.Services)
        {
            // Generate Server Controller
            sb
                .AppendLine()
                .AppendLine("[ApiController]")
                .AppendLine($"[Route(\"{service.Name}\")]")
                .AppendLine($"public abstract class {service.Name}ControllerBase : ControllerBase")
                .AppendLine("{");

            foreach (Endpoint endpoint in service.Endpoints)
            {
                string httpMethodAttribute = endpoint.Node.Method switch
                {
                    HttpMethod.Get => "HttpGet",
                    HttpMethod.Post => "HttpPost",
                    HttpMethod.Put => "HttpPut",
                    HttpMethod.Patch => "HttpPatch",
                    HttpMethod.Delete => "HttpDelete",
                    HttpMethod.Options => "HttpOptions",
                    HttpMethod.Trace => "HttpTrace",
                    _ => throw new ArgumentOutOfRangeException()
                };

                sb.AppendLine($"    [{httpMethodAttribute}(\"{endpoint.Node.Path.TrimStart('/')}\", Name = \"{endpoint.Name}\")]");
                sb.AppendLine($"    public abstract Task<ActionResult<{endpoint.ResponseType.Name}>> {endpoint.Name}({endpoint.ResponseType.Name} request);");
                sb.AppendLine();
            }

            sb.AppendLine("}");
        }

        return new CompiledFile(file.Name, sb.ToString());
    }

    protected override string GetCompiledFilePath(FileNode fileNode)
    {
        string newFilePath = StringExtensions.FilePathToPascalCase(fileNode.FilePath) + ".cs";
        return newFilePath;
    }

    protected override string? GetCompiledNamespace(FileNode fileNode)
    {
        return fileNode.Namespace.ToPascalCase();
    }
    
    protected override string GetCompiledClassName(DefinitionNode definitionNode)
    {
        return definitionNode.Name.ToPascalCase();
    }

    protected override string GetCompiledEndpointName(EndpointNode endpointNode)
    {
        return endpointNode.Name.ToPascalCase();
    }

    protected override Include? GetCompiledIncludeForPropertyType(File file, IPropertyType propertyType)
    {
        switch (propertyType)
        {
            case ListType:
            case MapType:
            case SetType:
                return new Include("System.Collections.Generic");
            default:
                return null;
        }
    }
    

    protected override string GetCompiledPropertyName(PropertyNode propertyNode)
    {
        return propertyNode.Name.ToPascalCase();
    }

    protected override string GetCompiledServiceName(ServiceNode serviceNode)
    {
        return serviceNode.Name.ToPascalCase();
    }

    protected override PropertyType GetCompiledPropertyType(IPropertyType propertyType)
    {
        PropertyType genPropertyType;
        switch (propertyType)
        {
            case AnyType:
                genPropertyType = new PropertyType("object");
                break;
            case BooleanType:
                genPropertyType = new PropertyType("bool");
                break;
            case DateType:
                genPropertyType = new PropertyType("DateTime");
                break;
            case FloatType:
                genPropertyType = new PropertyType("double");
                break;
            case IntegerType:
                genPropertyType = new PropertyType("int");
                break;
            case ListType listType:
                PropertyType innerListPropertyType = GetCompiledPropertyType(listType.InnerType);
                genPropertyType = new PropertyType($"List<{innerListPropertyType.Name}>");
                break;
            case MapType mapType:
                PropertyType innerKeyPropertyType = GetCompiledPropertyType(mapType.InnerTypeA);
                PropertyType innerValuePropertyType = GetCompiledPropertyType(mapType.InnerTypeB);
                genPropertyType = new PropertyType($"Dictionary<{innerKeyPropertyType.Name}, {innerValuePropertyType.Name}>");
                break;
            case SetType setType:
                PropertyType innerSetPropertyType = GetCompiledPropertyType(setType.InnerType);
                genPropertyType = new PropertyType($"HashSet<{innerSetPropertyType.Name}>");
                break;
            case StringType:
                genPropertyType = new PropertyType("string");
                break;
            case TimeType:
                genPropertyType = new PropertyType("TimeSpan");
                break;
            case ObjectType userType:
                genPropertyType = new PropertyType(userType.Name.ToPascalCase());
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(propertyType));
        }

        if (propertyType is IOptionalPropertyType)
            genPropertyType = new PropertyType($"{genPropertyType.Name}?");

        return genPropertyType;
    }

    protected override PropertyValue GetCompiledDefaultValueForPropertyType(IPropertyType propertyType)
    {
        return propertyType switch
        {
            IOptionalPropertyType => new NoPropertyValue(),
            AnyType or ObjectType => new SomePropertyValue("new()"),
            ListType or MapType or SetType => new SomePropertyValue("[]"),
            StringType => new SomePropertyValue("string.Empty"),
            _ => new NoPropertyValue()
        };
    }

    protected override PropertyValue GetCompiledDesiredPropertyValue(IPropertyValue propertyValue)
    {
        switch (propertyValue)
        {
            case BooleanValue booleanValue:
                return new SomePropertyValue(booleanValue.Value ? "true" : "false");
            case DateValue dateValue:
                return new SomePropertyValue($"DateTime.Parse(\"{dateValue.Value:O}\")");
            case FloatValue floatValue:
                return new SomePropertyValue(floatValue.Value.ToString(CultureInfo.InvariantCulture));
            case IntegerValue integerValue:
                return new SomePropertyValue(integerValue.Value.ToString(CultureInfo.InvariantCulture));
            case ListValue listValue:
                StringBuilder sb = new();
                sb.Append('[');
                for (int itemIdx = 0; itemIdx < listValue.Values.Count; itemIdx++)
                {
                    IPropertyValue itemValue = listValue.Values[itemIdx];
                    sb.Append(GetCompiledDesiredPropertyValue(itemValue));
                    if (itemIdx < listValue.Values.Count - 1)
                        sb.Append(", ");
                }
                sb.Append(']');
                return new SomePropertyValue(sb.ToString());
            case MapValue mapValue:
                throw new NotImplementedException();
            case NullValue nullValue:
                return new SomePropertyValue("null");
            case ObjectValue objectValue:
                throw new NotImplementedException();
            case StringValue stringValue:
                return new SomePropertyValue($"\"{stringValue.Value}\"");
            case TimeValue timeValue:
                return new SomePropertyValue($"TimeSpan.FromSeconds({timeValue.Value.TotalSeconds.ToString(CultureInfo.InvariantCulture)})");
            default:
                throw new ArgumentOutOfRangeException();
        }
    }
    
    protected override IEnumerable<Function> CreateSerialiseFunction(File file, DefinitionNode definitionNode)
    {
        return [
            new Function(
                Name: "ToBytes",
                ReturnType: "byte[]",
                Flags: FunctionFlags.Const,
                Parameters: [],
                Body: "return System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(this);")
        ];
    }

    protected override IEnumerable<Function> CreateDeserialiseFunction(File file, DefinitionNode definitionNode)
    {
        return [
            new Function(
                Name: "FromBytes",
                ReturnType: $"{definitionNode.Name.ToPascalCase()}?",
                Flags: FunctionFlags.Static,
                Parameters: ["ReadOnlySpan<byte> bytes"],
                Body: $"return System.Text.Json.JsonSerializer.Deserialize<{definitionNode.Name.ToPascalCase()}>(bytes);")
        ];
    }
}