using Catalyst.SpecGraph.Nodes;

namespace Catalyst.SpecGraph.Properties;

/// <summary>
/// Represents a type that can be used for a Definition's DataMember.
/// It will either represent a built-in Data Type or an 'object' Data Type that
/// was generated by a Spec File Definition.
/// </summary>
public interface IDataType
{
    public string Name { get; }

    public bool Matches(string compare)
    {
        return Name == compare || $"{Name}?" == compare;
    }

    public static bool IsOptional(string rawDataType) =>
        rawDataType.EndsWith('?');

    public static bool IsOptional(IDataType dataType) =>
        dataType is IOptionalDataType;
}

/// <summary>
/// Used to tag a Data Type as an 'optional'/'nullable' Data Type.
/// </summary>
public interface IOptionalDataType;

public interface IUserDataType : IDataType
{
    public string? Namespace { get; set; }
    public FileNode OwnedFile { get; set; }
}

public class BooleanType : IDataType
{
    public virtual string Name => "bool";
}

public class OptionalBooleanType : BooleanType, IOptionalDataType
{
    public override string Name => "bool?";
}

public class IntegerType : IDataType
{
    public virtual string Name => "i32";
}

public class OptionalIntegerType : IntegerType, IOptionalDataType
{
    public override string Name => "i32?";
}

public class Integer64Type : IDataType
{
    public virtual string Name => "i64";
}

public class OptionalInteger64Type : Integer64Type, IOptionalDataType
{
    public override string Name => "i64?";
}

public class FloatType : IDataType
{
    public virtual string Name => "f64";
}

public class OptionalFloatType : FloatType, IOptionalDataType
{
    public override string Name => "f64?";
}

public class StringType : IDataType
{
    public virtual string Name => "str";
}

public class OptionalStringType : StringType, IOptionalDataType
{
    public override string Name => "str?";
}

public class DateType : IDataType
{
    public virtual string Name => "date";
}

public class OptionalDateType : DateType, IOptionalDataType
{
    public override string Name => "date?";
}

public class TimeType : IDataType
{
    public virtual string Name => "time";
}

public class OptionalTimeType : TimeType, IOptionalDataType
{
    public override string Name => "time?";
}

public class UuidType : IDataType
{
    public virtual string Name => "uuid";
}

public class OptionalUuidType : UuidType, IOptionalDataType
{
    public override string Name => "uuid?";
}

public class AnyType : IDataType, IOptionalDataType
{
    public string Name => "any";
}

/// <summary>
/// Used to represent a 'templated' container of Property Types.
/// Such containers have 'inner' Property Types to represent the Property Types
/// they contain.
/// </summary>
public interface IPropertyContainerType : IDataType
{
    public static Tuple<int, int>? GetInnerPropertyTypesRange(string propertyType)
    {
        Tuple<int, int> tuple = new(propertyType.IndexOf('<'), propertyType.LastIndexOf('>'));
        if (tuple.Item1 == -1 || tuple.Item2 == -1)
            return null;

        return new Tuple<int, int>(tuple.Item1 + 1, tuple.Item2);
    }

    public static string[] GetRawInnerPropertyTypes(string propertyType)
    {
        Tuple<int, int>? innerTypesRange = GetInnerPropertyTypesRange(propertyType);
        
        if (innerTypesRange is null)
            throw new ArgumentOutOfRangeException($"Property type '{propertyType}' is not a valid container type");
        
        string innerTypesStr = propertyType[innerTypesRange.Item1..innerTypesRange.Item2];
        
        innerTypesStr = innerTypesStr.Replace(" ", string.Empty);
        
        string[] innerTypes = innerTypesStr.Split(',');
        if (innerTypes.Length == 0)
            throw new InvalidOperationException($"Property type '{propertyType}' is not a valid container type");
        
        return innerTypes;
    }

    bool IDataType.Matches(string compare)
    {
        // Containers match when:
        // 1. They have the same number of inner types.
        // 2. They start with the same name.
        
        Tuple<int, int> baseTypesRange = GetInnerPropertyTypesRange(Name) ?? throw new InvalidOperationException();
        Tuple<int, int>? compareTypesRange = GetInnerPropertyTypesRange(compare);
        
        // Compare is not a container.
        if (compareTypesRange is null)
            return false;
        
        string baseName = Name[..baseTypesRange.Item1];
        string compareName = Name[..compareTypesRange.Item1];

        if (baseName != compareName)
            return false;
        
        string[] baseInnerTypes = GetRawInnerPropertyTypes(Name);
        string[] compareInnerTypes = GetRawInnerPropertyTypes(compare);
        return baseInnerTypes.Length == compareInnerTypes.Length;
    }
}

/// <summary>
/// Represents a Property Container that contains a single 'inner' Property Type.
/// </summary>
public interface IPropertyContainer1InnerType : IPropertyContainerType
{
    IDataType InnerType { get; set; }

    public static string ExtractRawInnerType(string rawContainerType)
    {
        return GetRawInnerPropertyTypes(rawContainerType).First();
    }
}

/// <summary>
/// Represents a Property Container that contains a two 'inner' Property Types.
/// </summary>
public interface IPropertyContainer2InnerTypes : IPropertyContainerType
{
    IDataType InnerTypeA { get; set; }
    IDataType InnerTypeB { get; set; }

    public static Tuple<string, string> ExtractRawInnerTypes(string rawContainerType)
    {
        string[] innerTypes = GetRawInnerPropertyTypes(rawContainerType);
        return new(innerTypes[0], innerTypes[1]);
    }
}

public class ListType : IPropertyContainer1InnerType
{
    public required string Name { get; set; }
    public required IDataType InnerType { get; set; }
}
public class OptionalListType : ListType, IOptionalDataType;

public class SetType : IPropertyContainer1InnerType
{
    public required string Name { get; set; }
    public required IDataType InnerType { get; set; }
}
public class OptionalSetType : SetType, IOptionalDataType;

public class MapType : IPropertyContainer2InnerTypes
{
    public required string Name { get; set; }
    public required IDataType InnerTypeA { get; set; }
    public required IDataType InnerTypeB { get; set; }
}
public class OptionalMapType : MapType, IOptionalDataType;

public class ObjectType : IUserDataType
{
    public required string Name { get; set; }
    public required string? Namespace { get; set; }
    public required FileNode OwnedFile { get; set; }
    public required DefinitionNode OwnedDefinition { get; set; }
}
public class OptionalObjectType : ObjectType, IOptionalDataType;

public class EnumType : IUserDataType
{
    public required string Name { get; set; }
    public required string? Namespace { get; set; }
    public required FileNode OwnedFile { get; set; }
    public required EnumNode OwnedEnum { get; set; }
}

public class OptionalEnumType : EnumType, IOptionalDataType;
