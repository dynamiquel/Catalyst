using System.Text;
using Catalyst.SpecGraph.Properties;
using Catalyst.SpecGraph.Nodes;

namespace Catalyst.Generators.CSharp;

public class CSharpCompiler : Compiler
{
    public override string Name => CSharp.Name;

    public CSharpCompiler(CompilerOptions options) : base(options)
    {
    }

    public override CompiledFile Compile(BuiltFile file)
    {
        StringBuilder sb = new();
        
        sb.AppendLine("//");
        sb.AppendLine($"// This file was generated by Catalyst's C# compiler at {DateTime.Now}.");
        sb.AppendLine("// It is recommended not to modify this file. Modify the source spec file instead.");
        sb.AppendLine("//");
        sb.AppendLine();
        
        if (file.Includes.Count > 0)
        {
            foreach (BuiltInclude include in file.Includes)
                sb.AppendLine($"using {include.Path};");
            sb.AppendLine();
        }
        
        if (!string.IsNullOrWhiteSpace(file.Namespace))
            sb.AppendLine($"namespace {file.Namespace};").AppendLine();

        foreach (var builtEnum in file.Enums)
        {
            AppendDescriptionComment(sb, builtEnum.Node);

            if (builtEnum.Node.Flags == true)
                sb.AppendLine("[Flags]");
            
            sb
                .AppendLine($"[JsonConverter(typeof(JsonStringEnumConverter<{builtEnum.Name}>))]")
                .AppendLine($"public enum {builtEnum.Name}")
                .AppendLine("{");

            for (var enumValueIdx = 0; enumValueIdx < builtEnum.Values.Count; enumValueIdx++)
            {
                BuiltEnumValue builtEnumValue = builtEnum.Values[enumValueIdx];
                sb.Append($"    {builtEnumValue.Label} = {builtEnumValue.Value}");

                if (enumValueIdx < builtEnum.Values.Count - 1)
                    sb.Append(',');
                
                sb.AppendLine();
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        for (var defIdx = 0; defIdx < file.Definitions.Count; defIdx++)
        {
            BuiltDefinition def = file.Definitions[defIdx];
            
            AppendDescriptionComment(sb, def.Node);

            CSharpClassType classType = def.Node.FindCompilerOptions<CSharpDefinitionOptionsNode>()!.Type;
            string classTypeStr = classType == CSharpClassType.Class ? "class" : "record";
            sb.AppendLine($"public {classTypeStr} {def.Name}").AppendLine("{");

            if (def.Constants.Count > 0)
            {
                for (var constantIdx = 0; constantIdx < def.Constants.Count; constantIdx++)
                {
                    BuiltConstant constant = def.Constants[constantIdx];

                    AppendDescriptionComment(sb, constant.Node, 1);

                    switch (constant.Node.BuiltType)
                    {
                        case IntegerType:
                        case Integer64Type:
                        case FloatType:
                        case BooleanType:
                        case StringType:
                        case EnumType:
                            sb.Append($"    public const {constant.Type.Name} {constant.Name} = {constant.Value.Value};");
                            break;
                        default:
                            sb.Append($"    public static readonly {constant.Type.Name} {constant.Name} = {constant.Value.Value};");
                            break;
                    }

                    sb.AppendLine();

                    if (constantIdx < def.Constants.Count - 1)
                        sb.AppendLine();
                }

                sb.AppendLine();
            }

            for (var propertyIdx = 0; propertyIdx < def.Properties.Count; propertyIdx++)
            {
                BuiltProperty property = def.Properties[propertyIdx];
                /*if (property.Attributes.Count > 0)
                {
                    sb.Append("    ");
                    foreach (Attribute attribute in property.Attributes)
                    {
                        sb.Append($"[{attribute.Name}");
                        if (!string.IsNullOrWhiteSpace(attribute.Arguments))
                            sb.Append($"({attribute.Arguments})");
                        sb.AppendLine("]");
                    }
                }*/

                AppendDescriptionComment(sb, property.Node, 1);

                bool useRequired = property.Node.FindCompilerOptions<CSharpPropertyOptionsNode>()!.UseRequired;

                sb.Append("    public");
                if (useRequired && !property.Type.Name.EndsWith("?"))
                    sb.Append(" required");

                sb.Append($" {property.Type.Name} {property.Name} {{ get; set; }}");

                if (!useRequired && property.Value is not NoDataValue)
                    sb.Append($" = {property.Value.Value};");

                sb.AppendLine();

                if (propertyIdx < def.Properties.Count - 1)
                    sb.AppendLine();
            }

            foreach (BuiltFunction function in def.Functions)
            {
                sb.AppendLine();

                sb.Append("    public ");

                if (function.Flags is FunctionFlags.Static)
                    sb.Append("static ");

                sb.Append($"{function.ReturnType} {function.Name}(");

                for (int parameterIdx = 0; parameterIdx < function.Parameters.Count; parameterIdx++)
                {
                    sb.Append(function.Parameters[parameterIdx]);
                    if (parameterIdx < function.Parameters.Count - 1)
                        sb.Append(", ");
                }

                sb.AppendLine(")");

                sb.AppendLine("    {");

                sb.AppendLine($"        {function.Body}");

                sb.AppendLine("    }");
            }

            sb.AppendLine("}");
            
            if (defIdx < file.Definitions.Count - 1)
                sb.AppendLine();
        }

        sb.AppendLine();

        if (file.Definitions.Count > 0)
        {
            // JSON Serialiser Context
            sb
                .AppendLine("[JsonSourceGenerationOptions(")
                .AppendLine("    WriteIndented = false,")
                .AppendLine("    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,")
                .AppendLine("    NumberHandling = JsonNumberHandling.AllowReadingFromString,")
                .AppendLine("    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,")
                .AppendLine("    PropertyNameCaseInsensitive = true)]");
            foreach (var def in file.Definitions)
                sb.AppendLine($"[JsonSerializable(typeof({def.Name}))]");
            sb.AppendLine(
                $"public partial class {file.Node.FileName.ToPascalCase()}JsonContext : JsonSerializerContext;");
        }

        // TODO: Redo BuiltService and BuiltEndpoint. The implementation details should be generated
        // in the Build stage, not the Compile stage.
        if (ClientServiceBuilder is not null)
            foreach (BuiltService service in file.Services)
                ClientServiceBuilder.Compile(file, service, sb);
        
        if (ServerServiceBuilder is not null)
            foreach (BuiltService service in file.Services)
                ServerServiceBuilder.Compile(file, service, sb);
        
        if (ValidatorBuilder is not null)
            foreach (BuiltValidator validator in file.Validators)
                ValidatorBuilder.Compile(file, validator, sb);
        
        return new CompiledFile(file.Name, sb.ToString());
    }

    public override BuiltInclude? GetCompiledIncludeForType(BuiltFile file, IDataType dataType)
    {
        return dataType switch
        {
            ListType or MapType or SetType => new BuiltInclude("System.Collections.Generic"),
            _ => null
        };
    }

    public override BuiltDataType GetCompiledDataType(IDataType dataType)
    {
        BuiltDataType builtDataType;
        switch (dataType)
        {
            case AnyType:
                builtDataType = new BuiltDataType("object");
                break;
            case BooleanType:
                builtDataType = new BuiltDataType("bool");
                break;
            case DateType:
                builtDataType = new BuiltDataType("DateTime");
                break;
            case FloatType:
                builtDataType = new BuiltDataType("double");
                break;
            case IntegerType:
                builtDataType = new BuiltDataType("int");
                break;
            case Integer64Type:
                builtDataType = new BuiltDataType("long");
                break;
            case ListType listType:
                BuiltDataType innerListPropertyType = GetCompiledDataType(listType.InnerType);
                builtDataType = new BuiltDataType($"List<{innerListPropertyType.Name}>");
                break;
            case MapType mapType:
                BuiltDataType innerKeyPropertyType = GetCompiledDataType(mapType.InnerTypeA);
                BuiltDataType innerValuePropertyType = GetCompiledDataType(mapType.InnerTypeB);
                builtDataType = new BuiltDataType($"Dictionary<{innerKeyPropertyType.Name}, {innerValuePropertyType.Name}>");
                break;
            case SetType setType:
                BuiltDataType innerSetPropertyType = GetCompiledDataType(setType.InnerType);
                builtDataType = new BuiltDataType($"HashSet<{innerSetPropertyType.Name}>");
                break;
            case StringType:
                builtDataType = new BuiltDataType("string");
                break;
            case TimeType:
                builtDataType = new BuiltDataType("TimeSpan");
                break;
            case UuidType:
                builtDataType = new BuiltDataType("Guid");
                break;
            case IUserDataType userType:
                builtDataType = new BuiltDataType(userType.Name.ToPascalCase());
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(dataType));
        }

        if (dataType is IOptionalDataType)
            builtDataType = new BuiltDataType($"{builtDataType.Name}?");

        return builtDataType;
    }

    public override string? GetCompiledNamespace(string? namespaceName)
    {
        return namespaceName.ToPascalCase();
    }

    public override string GetCompiledClassName(string className)
    {
        return className.ToPascalCase();
    }
    
    public StringBuilder AppendDescriptionComment(StringBuilder sb, INodeDescription node, int indentation = 0)
    {
        if (string.IsNullOrEmpty(node.Description)) 
            return sb;

        for (int indent = 0; indent < indentation; indent++)
            sb.Append("    ");
        sb.AppendLine("/// <summary>");
        
        string[] descLines = node.Description.Split('\n');
        foreach (string descLine in descLines)
        {
            for (int indent = 0; indent < indentation; indent++)
                sb.Append("    ");
            sb.AppendLine($"/// {descLine}");
        }

        for (int indent = 0; indent < indentation; indent++)
            sb.Append("    ");
        sb.AppendLine("/// </summary>");

        return sb;
    }
}