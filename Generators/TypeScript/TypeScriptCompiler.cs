using System.Text;
using Catalyst.SpecGraph.Properties;
using Catalyst.SpecGraph.Nodes;

namespace Catalyst.Generators.TypeScript;

public class TypeScriptCompiler : Compiler
{
    public override string Name => TypeScript.Name;

    public TypeScriptCompiler(CompilerOptions options) : base(options)
    {
    }

    public override CompiledFile Compile(BuiltFile file)
    {
        StringBuilder sb = new();

        sb.AppendLine("//");
        sb.AppendLine($"// This file was generated by Catalyst's TypeScript compiler at {DateTime.Now}.");
        sb.AppendLine("// It is recommended not to modify this file. Modify the source spec file instead.");
        sb.AppendLine("//");
        sb.AppendLine();

        foreach (var builtEnum in file.Enums)
        {
            AppendDescriptionComment(sb, builtEnum.Node);
            sb.AppendLine($"export enum {builtEnum.Name} {{");

            for (var enumValueIdx = 0; enumValueIdx < builtEnum.Values.Count; enumValueIdx++)
            {
                BuiltEnumValue builtEnumValue = builtEnum.Values[enumValueIdx];
                sb.Append($"    {builtEnumValue.Label} = {builtEnumValue.Value}");
                if (enumValueIdx < builtEnum.Values.Count - 1)
                    sb.Append(',');
                sb.AppendLine();
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        for (var defIdx = 0; defIdx < file.Definitions.Count; defIdx++)
        {
            BuiltDefinition def = file.Definitions[defIdx];

            AppendDescriptionComment(sb, def.Node);
            sb.AppendLine($"export class {def.Name} {{");

            for (var propertyIdx = 0; propertyIdx < def.Properties.Count; propertyIdx++)
            {
                BuiltProperty property = def.Properties[propertyIdx];
                bool isOptional = property.Node.BuiltType is IOptionalPropertyType;

                AppendDescriptionComment(sb, property.Node, 1);

                sb.Append("    public ");
                sb.Append(property.Name);
                if (isOptional)
                    sb.Append("?");
                sb.Append($": {property.Type.Name}");

                if (property.Value is SomePropertyValue some && !isOptional)
                    sb.Append($" = {some.Value}");
                sb.AppendLine(";");

                if (propertyIdx < def.Properties.Count - 1)
                    sb.AppendLine();
            }

            foreach (BuiltFunction function in def.Functions)
            {
                sb.AppendLine();

                bool isStatic = function.Flags is FunctionFlags.Static;
                sb.Append("    public ");
                if (isStatic)
                    sb.Append("static ");

                sb.Append($"{function.Name}(");
                for (int parameterIdx = 0; parameterIdx < function.Parameters.Count; parameterIdx++)
                {
                    sb.Append(function.Parameters[parameterIdx]);
                    if (parameterIdx < function.Parameters.Count - 1)
                        sb.Append(", ");
                }
                sb.Append(")");
                if (!string.IsNullOrWhiteSpace(function.ReturnType))
                    sb.Append($": {function.ReturnType}");
                sb.AppendLine();
                sb.AppendLine("    {");
                if (function.Body is not null)
                {
                    string[] lines = function.Body.Split(Environment.NewLine);
                    foreach (string line in lines)
                        sb.AppendLine($"        {line}");
                }
                sb.AppendLine("    }");
            }

            // Default serialisation helpers if none provided
            if (!def.Functions.Any(f => f.Name == "toBytes"))
            {
                sb.AppendLine();
                sb.AppendLine("    public toBytes(): Uint8Array");
                sb.AppendLine("    {");
                sb.AppendLine("        const json = JSON.stringify(this);");
                sb.AppendLine("        return new TextEncoder().encode(json);");
                sb.AppendLine("    }");
            }
            if (!def.Functions.Any(f => f.Name == "fromBytes"))
            {
                sb.AppendLine();
                sb.AppendLine($"    public static fromBytes(bytes: Uint8Array): {def.Name} | null");
                sb.AppendLine("    {");
                sb.AppendLine("        try {");
                sb.AppendLine("            const json = new TextDecoder().decode(bytes);");
                sb.AppendLine($"            const obj = JSON.parse(json) as {def.Name};");
                sb.AppendLine($"            return Object.assign(new {def.Name}(), obj);");
                sb.AppendLine("        } catch { return null; }");
                sb.AppendLine("    }");
            }

            sb.AppendLine("}");

            if (defIdx < file.Definitions.Count - 1)
                sb.AppendLine();
        }

        if (ClientServiceBuilder is not null)
            foreach (BuiltService service in file.Services)
                ClientServiceBuilder.Compile(file, service, sb);

        return new CompiledFile(file.Name, sb.ToString());
    }

    public override BuiltInclude? GetCompiledIncludeForType(BuiltFile file, IPropertyType propertyType)
    {
        return null;
    }

    public override BuiltPropertyType GetCompiledPropertyType(IPropertyType propertyType)
    {
        BuiltPropertyType genPropertyType;
        switch (propertyType)
        {
            case AnyType:
                genPropertyType = new BuiltPropertyType("any");
                break;
            case BooleanType:
                genPropertyType = new BuiltPropertyType("boolean");
                break;
            case DateType:
                genPropertyType = new BuiltPropertyType("string");
                break;
            case FloatType:
                genPropertyType = new BuiltPropertyType("number");
                break;
            case IntegerType:
                genPropertyType = new BuiltPropertyType("number");
                break;
            case ListType listType:
                BuiltPropertyType innerListPropertyType = GetCompiledPropertyType(listType.InnerType);
                genPropertyType = new BuiltPropertyType($"Array<{innerListPropertyType.Name}>");
                break;
            case MapType mapType:
                BuiltPropertyType innerKeyPropertyType = GetCompiledPropertyType(mapType.InnerTypeA);
                BuiltPropertyType innerValuePropertyType = GetCompiledPropertyType(mapType.InnerTypeB);
                genPropertyType = new BuiltPropertyType($"Record<{innerKeyPropertyType.Name}, {innerValuePropertyType.Name}>");
                break;
            case SetType setType:
                BuiltPropertyType innerSetPropertyType = GetCompiledPropertyType(setType.InnerType);
                genPropertyType = new BuiltPropertyType($"Array<{innerSetPropertyType.Name}>");
                break;
            case StringType:
                genPropertyType = new BuiltPropertyType("string");
                break;
            case TimeType:
                genPropertyType = new BuiltPropertyType("number");
                break;
            case IUserPropertyType userType:
                genPropertyType = new BuiltPropertyType(userType.Name.ToPascalCase());
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(propertyType));
        }

        if (propertyType is IOptionalPropertyType)
            genPropertyType = new BuiltPropertyType($"{genPropertyType.Name} | null");

        return genPropertyType;
    }

    public override string? GetCompiledNamespace(string? namespaceName)
    {
        return null; // TS modules are file-scoped here
    }

    public override string GetCompiledClassName(string className)
    {
        return className.ToPascalCase();
    }

    public StringBuilder AppendDescriptionComment(StringBuilder sb, INodeDescription node, int indentation = 0)
    {
        if (string.IsNullOrEmpty(node.Description))
            return sb;

        for (int indent = 0; indent < indentation; indent++)
            sb.Append("    ");
        sb.AppendLine("/**");

        string[] descLines = node.Description.Split('\n');
        foreach (string descLine in descLines)
        {
            for (int indent = 0; indent < indentation; indent++)
                sb.Append("    ");
            sb.AppendLine($" * {descLine}");
        }

        for (int indent = 0; indent < indentation; indent++)
            sb.Append("    ");
        sb.AppendLine(" */");

        return sb;
    }
}

