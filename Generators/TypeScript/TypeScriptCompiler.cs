using System.Text;
using Catalyst.SpecGraph.Properties;
using Catalyst.SpecGraph.Nodes;

namespace Catalyst.Generators.TypeScript;

public class TypeScriptCompiler : Compiler
{
    public override string Name => TypeScript.Name;

    public TypeScriptCompiler(CompilerOptions options) : base(options)
    {
    }

    public override CompiledFile Compile(BuiltFile file)
    {
        StringBuilder sb = new();

        sb.AppendLine("//");
        sb.AppendLine($"// This file was generated by Catalyst's TypeScript compiler at {DateTime.Now}.");
        sb.AppendLine("// It is recommended not to modify this file. Modify the source spec file instead.");
        sb.AppendLine("//");
        sb.AppendLine();

        // Emit imports for referenced user-defined types across files
        var importMap = BuildTypeScriptImportMap(file);
        foreach (var import in importMap.OrderBy(kvp => kvp.Key))
        {
            string importPath = ComputeRelativeImportPath(file.Name, import.Key);
            string symbols = string.Join(", ", import.Value.OrderBy(x => x));
            sb.AppendLine($"import {{ {symbols} }} from '{importPath}';");
        }
        if (importMap.Count > 0)
            sb.AppendLine();

        foreach (var builtEnum in file.Enums)
        {
            AppendDescriptionComment(sb, builtEnum.Node);
            sb.AppendLine($"export enum {builtEnum.Name} {{");

            for (var enumValueIdx = 0; enumValueIdx < builtEnum.Values.Count; enumValueIdx++)
            {
                BuiltEnumValue builtEnumValue = builtEnum.Values[enumValueIdx];
                sb.Append($"    {builtEnumValue.Label} = {builtEnumValue.Value}");
                if (enumValueIdx < builtEnum.Values.Count - 1)
                    sb.Append(',');
                sb.AppendLine();
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        for (var defIdx = 0; defIdx < file.Definitions.Count; defIdx++)
        {
            BuiltDefinition def = file.Definitions[defIdx];

            AppendDescriptionComment(sb, def.Node);
            sb.AppendLine($"export class {def.Name} {{");

            if (def.Constants.Count > 0)
            {
                for (var constantIdx = 0; constantIdx < def.Constants.Count; constantIdx++)
                {
                    BuiltConstant constant = def.Constants[constantIdx];

                    AppendDescriptionComment(sb, constant.Node, 1);

                    sb.Append($"    static readonly {constant.Name}: {constant.Type.Name} = {constant.Value.Value};");

                    sb.AppendLine();

                    if (constantIdx < def.Constants.Count - 1)
                        sb.AppendLine();
                }

                sb.AppendLine();
            }

            for (var propertyIdx = 0; propertyIdx < def.Properties.Count; propertyIdx++)
            {
                BuiltProperty property = def.Properties[propertyIdx];
                bool isOptional = property.Node.BuiltType is IOptionalPropertyType;

                AppendDescriptionComment(sb, property.Node, 1);

                sb.Append("    public ");
                sb.Append(property.Name);
                if (isOptional)
                    sb.Append("?");
                sb.Append($": {property.Type.Name}");

                if (property.Value is SomePropertyValue some && !isOptional)
                    sb.Append($" = {some.Value}");
                sb.AppendLine(";");

                if (propertyIdx < def.Properties.Count - 1)
                    sb.AppendLine();
            }

            foreach (BuiltFunction function in def.Functions)
            {
                sb.AppendLine();

                bool isStatic = function.Flags is FunctionFlags.Static;
                sb.Append("    public ");
                if (isStatic)
                    sb.Append("static ");

                sb.Append($"{function.Name}(");
                for (int parameterIdx = 0; parameterIdx < function.Parameters.Count; parameterIdx++)
                {
                    sb.Append(function.Parameters[parameterIdx]);
                    if (parameterIdx < function.Parameters.Count - 1)
                        sb.Append(", ");
                }
                sb.Append(")");
                if (!string.IsNullOrWhiteSpace(function.ReturnType))
                    sb.Append($": {function.ReturnType}");
                sb.AppendLine();
                sb.AppendLine("    {");
                if (function.Body is not null)
                {
                    string[] lines = function.Body.Split(Environment.NewLine);
                    foreach (string line in lines)
                        sb.AppendLine($"        {line}");
                }
                sb.AppendLine("    }");
            }

            // Default serialisation helpers if none provided
            if (!def.Functions.Any(f => f.Name == "toBytes"))
            {
                sb.AppendLine();
                sb.AppendLine("    public toBytes(): Uint8Array");
                sb.AppendLine("    {");
                sb.AppendLine("        const json = JSON.stringify(this);");
                sb.AppendLine("        return new TextEncoder().encode(json);");
                sb.AppendLine("    }");
            }
            if (!def.Functions.Any(f => f.Name == "fromBytes"))
            {
                sb.AppendLine();
                sb.AppendLine($"    public static fromBytes(bytes: Uint8Array): {def.Name} | null");
                sb.AppendLine("    {");
                sb.AppendLine("        try {");
                sb.AppendLine("            const json = new TextDecoder().decode(bytes);");
                sb.AppendLine($"            const obj = JSON.parse(json) as {def.Name};");
                sb.AppendLine($"            return Object.assign(new {def.Name}(), obj);");
                sb.AppendLine("        } catch { return null; }");
                sb.AppendLine("    }");
            }

            sb.AppendLine("}");

            if (defIdx < file.Definitions.Count - 1)
                sb.AppendLine();
        }

        if (ClientServiceBuilder is not null)
            foreach (BuiltService service in file.Services)
                ClientServiceBuilder.Compile(file, service, sb);

        return new CompiledFile(file.Name, sb.ToString());
    }

    public override BuiltInclude? GetCompiledIncludeForType(BuiltFile file, IPropertyType propertyType)
    {
        return null;
    }

    public override BuiltPropertyType GetCompiledPropertyType(IPropertyType propertyType)
    {
        BuiltPropertyType genPropertyType;
        switch (propertyType)
        {
            case AnyType:
                genPropertyType = new BuiltPropertyType("any");
                break;
            case BooleanType:
                genPropertyType = new BuiltPropertyType("boolean");
                break;
            case DateType:
                genPropertyType = new BuiltPropertyType("string");
                break;
            case FloatType:
                genPropertyType = new BuiltPropertyType("number");
                break;
            case IntegerType:
                genPropertyType = new BuiltPropertyType("number");
                break;
            case Integer64Type:
                genPropertyType = new BuiltPropertyType("bigint");
                break;
            case ListType listType:
                BuiltPropertyType innerListPropertyType = GetCompiledPropertyType(listType.InnerType);
                genPropertyType = new BuiltPropertyType($"Array<{innerListPropertyType.Name}>");
                break;
            case MapType mapType:
                BuiltPropertyType innerKeyPropertyType = GetCompiledPropertyType(mapType.InnerTypeA);
                BuiltPropertyType innerValuePropertyType = GetCompiledPropertyType(mapType.InnerTypeB);
                genPropertyType = new BuiltPropertyType($"Record<{innerKeyPropertyType.Name}, {innerValuePropertyType.Name}>");
                break;
            case SetType setType:
                BuiltPropertyType innerSetPropertyType = GetCompiledPropertyType(setType.InnerType);
                genPropertyType = new BuiltPropertyType($"Array<{innerSetPropertyType.Name}>");
                break;
            case StringType:
                genPropertyType = new BuiltPropertyType("string");
                break;
            case TimeType:
                genPropertyType = new BuiltPropertyType("number");
                break;
            case UuidType:
                genPropertyType = new BuiltPropertyType("string");
                break;
            case IUserPropertyType userType:
                // For TS, emit only the simple identifier (no namespaces, no optional marker)
                string typeName = userType.Name;
                if (!string.IsNullOrEmpty(typeName) && typeName.EndsWith("?"))
                    typeName = typeName[..^1];

                int lastDotIdx = typeName.LastIndexOf('.');
                if (lastDotIdx >= 0 && lastDotIdx < typeName.Length - 1)
                    typeName = typeName[(lastDotIdx + 1)..];

                genPropertyType = new BuiltPropertyType(typeName.ToPascalCase());
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(propertyType));
        }

        if (propertyType is IOptionalPropertyType)
            genPropertyType = new BuiltPropertyType($"{genPropertyType.Name} | null");

        return genPropertyType;
    }

    public override string? GetCompiledNamespace(string? namespaceName)
    {
        return null; // TS modules are file-scoped here
    }

    public override string GetCompiledClassName(string className)
    {
        return className.ToPascalCase();
    }

    public StringBuilder AppendDescriptionComment(StringBuilder sb, INodeDescription node, int indentation = 0)
    {
        if (string.IsNullOrEmpty(node.Description))
            return sb;

        for (int indent = 0; indent < indentation; indent++)
            sb.Append("    ");
        sb.AppendLine("/**");

        string[] descLines = node.Description.Split('\n');
        foreach (string descLine in descLines)
        {
            for (int indent = 0; indent < indentation; indent++)
                sb.Append("    ");
            sb.AppendLine($" * {descLine}");
        }

        for (int indent = 0; indent < indentation; indent++)
            sb.Append("    ");
        sb.AppendLine(" */");

        return sb;
    }

    private Dictionary<string, HashSet<string>> BuildTypeScriptImportMap(BuiltFile file)
    {
        var map = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);

        // Collect from definitions
        foreach (BuiltDefinition def in file.Definitions)
        foreach (BuiltProperty prop in def.Properties)
            CollectImportsForPropertyType(file, prop.Node.BuiltType!, map);

        // Collect from services
        foreach (BuiltService service in file.Services)
        foreach (BuiltEndpoint endpoint in service.Endpoints)
        {
            CollectImportsForPropertyType(file, endpoint.Node.BuiltRequestType!, map);
            CollectImportsForPropertyType(file, endpoint.Node.BuiltResponseType!, map);
        }

        return map;
    }

    private void CollectImportsForPropertyType(BuiltFile currentFile, IPropertyType type, Dictionary<string, HashSet<string>> map)
    {
        switch (type)
        {
            case ListType listType:
                CollectImportsForPropertyType(currentFile, listType.InnerType, map);
                break;
            case SetType setType:
                CollectImportsForPropertyType(currentFile, setType.InnerType, map);
                break;
            case MapType mapType:
                CollectImportsForPropertyType(currentFile, mapType.InnerTypeA, map);
                CollectImportsForPropertyType(currentFile, mapType.InnerTypeB, map);
                break;
            case IUserPropertyType userType:
            {
                string symbol = GetSimpleUserTypeName(userType);
                string targetFile = GetBuiltFileNameForUserType(userType);
                // Skip self-file
                if (string.Equals(targetFile, currentFile.Name, StringComparison.OrdinalIgnoreCase))
                    return;

                if (!map.TryGetValue(targetFile, out var symbols))
                {
                    symbols = new HashSet<string>(StringComparer.Ordinal);
                    map[targetFile] = symbols;
                }
                symbols.Add(symbol);
                break;
            }
        }
    }

    private string GetSimpleUserTypeName(IUserPropertyType userType)
    {
        string typeName = userType.Name;
        if (!string.IsNullOrEmpty(typeName) && typeName.EndsWith("?"))
            typeName = typeName[..^1];
        int lastDotIdx = typeName.LastIndexOf('.');
        if (lastDotIdx >= 0 && lastDotIdx < typeName.Length - 1)
            typeName = typeName[(lastDotIdx + 1)..];
        return typeName.ToPascalCase();
    }

    private string GetBuiltFileNameForUserType(IUserPropertyType userType)
    {
        if (userType is ObjectType obj)
        {
            return DefinitionBuilder.GetBuiltFileName(new BuildContext(obj.OwnedFile, []), obj.OwnedDefinition);
        }
        if (userType is EnumType en)
        {
            return EnumBuilder.GetBuiltFileName(new BuildContext(en.OwnedFile, []), en.OwnedEnum);
        }
        // Fallback shouldn't happen
        return string.Empty;
    }

    private string ComputeRelativeImportPath(string fromFile, string toFile)
    {
        string fromDir = System.IO.Path.GetDirectoryName(fromFile)?.Replace('\\', '/') ?? string.Empty;
        string toPath = toFile.Replace('\\', '/');
        string rel = System.IO.Path.GetRelativePath(string.IsNullOrEmpty(fromDir) ? "." : fromDir, toPath)
            .Replace('\\', '/');

        // Drop extension
        if (rel.EndsWith(".ts", StringComparison.OrdinalIgnoreCase))
            rel = rel.Substring(0, rel.Length - 3);

        if (!rel.StartsWith(".") && !rel.StartsWith("/"))
            rel = "./" + rel;
        return rel;
    }
}

